<head>
	<link rel="stylesheet" type="text/css" href="style.css">
	<script src="plotly-latest.min.js"></script>
</head>

<!--<div id="tester" style="width:600px;height:250px;"></div>-->

<body>
	<p id="maintitle">Data Visualization</p>
	<div class="section">
		<p id="directions"></p>
	</div>
	<div id="displayResponses"></div>
	<div id="results"></div>
	<div id="score"></div>
	<div id="table"></div>
</body>


<script>
	//about javascript synchronous/asynchronous
	//https://stackoverflow.com/questions/2035645/when-is-javascript-synchronous
	//as a note, setTimeout does NOT stop the code below it from running.
	window.onload = function() {
		/***************
		*  CONSTANTS  *
		***************/

		//sets the [default] range of values for random number generation
		const MIN = 0;
		const MAX = 9;

		//sets the [default] size of our matrix of data
		const ROWS = 10;
		const COLS = 10;

		//sets how long the visuals will be displayed
		//const WAIT_MILLIS = 5000;
		const WAIT_MILLIS = 3500;

		//name of graph
		const NAME = 'table';
		const RESULT_NAME = 'results';

		//arrays for tracking the responses given
		const RESPONSES = [];
		const CORRECT_RESPONSES = [];

		/***************
		*   CLASSES   *
		***************/

		//encapsilates information about an event to place in the queue
		function Event(run, shouldReadyNext) {
			//0 argument function to be run by EVENT_QUEUE
			this.run = run;

			//boolean indicating whether or not to ready the function after
			//this in EVENT_QUEUE to be run
			this.shouldReadyNext = shouldReadyNext;
		}

		//used to invoke asynchronus events in the proper order
		function EventQueue() {
			self = this;

			this.events = [];

			//sets the next event in the queue to run after WAIT_MILLIS
			this.readyNext = function() {
				//fill up the queue if it's empty
				if (self.events[0] == null) {
					self.populate();
				}

				setTimeout(self.runNext, WAIT_MILLIS);
			};

			//runs the next function, and then readies the one after it,
			//if indicated
			this.runNext = function() {
				let currentEvent = self.events.shift();

				if (currentEvent != null) {
					//run the current event
					currentEvent.run(ROWS, COLS);

					if (currentEvent.shouldReadyNext) {
						self.readyNext();
					}
				}
			};

			//adds a new event to the queue
			this.addEvent = function(newEvent)	{
				self.events.push(newEvent);
			};

			//clears the queue of all events
			this.clear = function() {
				self.events.length = 0;
			};

			//adds a call the each of the PLOTS to the queue
			this.populate = function() {
				for (i in PLOTS) {
					//NOTE: we don't need to wait for input when plotting,
					//      but we do after clearing the plot

					//add a plot to the queue...
					EVENT_QUEUE.addEvent(new Event(PLOTS[i], true));

					//...and a call to clear it
					EVENT_QUEUE.addEvent(new Event(clearVis, false));
				}
			}
		}

		/***************
		*  FUNCTIONS  *
		***************/

		// generates a random int between min and max
		function randGen(min, max)
		{
			return Math.round(Math.random() * (max-min) + min);
		}

		// Generates a rows by cols matrix of ints between min and max
		function matrixGen(co, ro, min, max)
		{
			var matrix = [];

			for (i = 0; i < ro; i++)
			{
				temp = [];
				for (j = 0; j < co; j++)
				{
					temp.push(randGen(min,max));
				}
				matrix.push(temp);
			}

			return matrix;
		}

		findFrequencies = function(valueArray) {
			//count the occurences of each value
			let freqs = {};
			let values = [];
			valueArray.forEach(function(subarr) {
				subarr.forEach(function(el) {
					if (el in freqs) {
						freqs[el]++;
					} else {
						freqs[el] = 1;
						values.push(el);
					}
				});
			});

			//sort the values in decending order of frequency
			values.sort((v0, v1) => freqs[v1] - freqs[v0]);
			//console.log(values);
			//console.log(freqs);

			if (freqs[values[0]] != freqs[values[1]]) {
				CORRECT_RESPONSES.push(values[0]);
			} else {
				CORRECT_RESPONSES.push("="); //TODO figure out a better system for ties
			}
			return freqs;
		}

		//plots a table of default size in the default range
		plotRandTable = function(rows, cols) {

			console.log("plotting table");

			//avoiding empty header
			let valueArray = matrixGen(cols, rows, MIN, MAX);

			findFrequencies(valueArray);

			let valueHeader = [];
			valueArray.forEach(function(subarr) {
				valueHeader.push(subarr.pop());
			});

			console.log("header" + valueHeader);
			console.log("array" + valueArray);

			let tableParams = [{
				type: 'table',
				header: {
					//values: [], //original
					values: valueHeader, //avoiding empty header
					align: "center",
					line: {width: 1, color: 'black'},
					fill: {color: "white"},
					font: {family: "Arial", size: 11, color: "black"},
					height: 20
				},
				cells: {
					values: valueArray,
					align: "center",
					line: {color: "black", width: 1},
					font: {family: "Arial", size: 11, color: ["black"]},
					height: 20
				}
			}];

			Plotly.plot(NAME, tableParams);
		}

		plotHeatMap = function(rows, cols) {
			let valueArray = matrixGen(cols, rows, MIN, MAX);

			findFrequencies(valueArray);

			var data = [
			{
				z: valueArray,
				type: 'heatmap',

			}
			];
			var axisTemplate = {
				//range: [MIN, MAX],
				//autorange: false,
				showgrid: false,
				zeroline: false,
				showticklabels: false,
				ticks: ''
			}
			var layout = {
				xaxis: axisTemplate,
				yaxis: axisTemplate
			};

			Plotly.newPlot(NAME, data, layout);
		}

		plotBarGraph = function(rows, cols) {
			let valueArray = matrixGen(cols, rows, MIN, MAX);

			let freqs = findFrequencies(valueArray);

			let x = [];
			let y = [];

			for (key in freqs){
				x.push(key);
				y.push(freqs[key]);
			}

			var data = [
			{
				x: x,
				y: y,
				type: 'bar'
			}
			];

			Plotly.newPlot(NAME, data);
		}

		//clears visuals and adds the option to give user input
		//input may need to be reworked/given more names, etc to put it in a table
		clearVis = function() {
			Plotly.purge(NAME);
			document.getElementById('directions').innerHTML = "<div><label>Your guess here: </label><input type=\"text\" id=\"usertext\"></div><button id=\"userclick\" onclick = \"offerInput();\">Submit</button><button onclick=\"displayResponses();\">Submit and show responses</button>";
		}

		//when the user submits a guess, this function is called.
		offerInput = function() {
			let inputobj = document.getElementById('usertext').value;
			if (inputobj.length > 2) {
				alert("Enter a realistic guess.");
			} else {
				RESPONSES.push(inputobj);
				document.getElementById('directions').innerHTML = "Find the mode (the most common number) in the graph below. Options are " + MIN + " to " + MAX + "\.";
				EVENT_QUEUE.readyNext();
			}
		}

		//shows the player a comparision between their responses
		//and the correct ones
		displayResponses = function() {
			var inputobj = document.getElementById('usertext').value;
			if (inputobj.length > 2) {
				alert("Enter a realistic guess.");
			}	else {
				RESPONSES.push(inputobj);
				document.getElementById('displayResponses').innerHTML = "";
				document.getElementById('directions').innerHTML = "<button onclick=\"resumeGame();\">Resume game</button><button onclick='endGame()'>End game</button>";

				var resultTableParams = [{
					type: 'table',
					header: {
						values: [["Correct responses"], ["Your responses"]],
						align: "center",
						line: {width: 1, color: 'black'},
						fill: {color: "gray"},
						font: {family: "Arial", size: 12, color: "white"},
						height: 28
					},
					cells: {
						values: [CORRECT_RESPONSES,RESPONSES],
						align: "center",
						line: {color: "black", width: 1},
						font: {family: "Arial", size: 11, color: ["black"]},
						height: 20
					}
				}];

				Plotly.plot(RESULT_NAME, resultTableParams);
			}
		}

		//when the user resumes the game, this function is called.
		resumeGame = function() {
			Plotly.purge(RESULT_NAME);
			document.getElementById('directions').innerHTML = "Find the mode (the most common number) in the graph below. Options are " + MIN + " to " + MAX + "\.";

			EVENT_QUEUE.readyNext();
		}

		//when the user ends the game, this function is called.
		endGame = function() {
			document.getElementById('directions').innerHTML = "";
			Plotly.purge(RESULT_NAME);

			//let their score be their success rate, for now
			let score = 0;
			for (i in RESPONSES) {
				if (RESPONSES[i] == CORRECT_RESPONSES[i]) {
					score++;
				}
			}
			score = 100.0 * score / RESPONSES.length;

			document.getElementById('score').innerHTML =
			"You had an accuracy of " + score + "%.";
			document.getElementById('directions').innerHTML =
			"<button onclick='restartGame()'>Restart game</button>";
		}

		restartGame = function() {
			//clear out the screen
			document.getElementById('score').innerHTML = "";

			//clear out the response lists
			RESPONSES.length = 0;
			CORRECT_RESPONSES.length = 0;

			//clear out the event queue
			EVENT_QUEUE.clear();

			//continue on with the new game
			main();
		}


		/***************
		*  MAIN BODY  *
		***************/

		//NOTE: PLOTS has to be defined after the definition of all
		//      the plotting functions in order to avoid errors

		//list of ploting functions
		const PLOTS = [
		plotHeatMap,
		plotRandTable,
		plotBarGraph
		];
		var EVENT_QUEUE = new EventQueue();

		function main() {
			//EVENT_QUEUE.populate();

			//display instructions
			document.getElementById('directions').innerHTML = "Find the mode (the most common number) in the graph below. Options are " + MIN + " to " + MAX + "\.";

			//start running events from the queue
			EVENT_QUEUE.readyNext();
		}

		main();
	};

</script>
